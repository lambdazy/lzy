syntax = "proto3";

package ai.lzy.v1.scheduler;

option java_outer_classname = "ServantAllocatorApi";
option java_package = "ai.lzy.v1";

import "ai/lzy/v1/zygote.proto";

//
// Public Servant Allocator API.
//
// Auth requirements: IAM Internal User
//
service ServantAllocator {
  rpc AllocateServant (AllocateServantRequest) returns (AllocateServantResponse);

  // explicit `DeallocateServant` call is not required, because `LzyServant` has a `Stop()` call
}

//
// Private Servant Allocator API.
//
// !!! Only for requests from servants !!!
//
// Auth requirements:
//  - RegisterServant: servant_id/one-time-token from bootstrap
//  - ServantStatus: servant_id/short-live-iam-token (from ServantAuth)
//
service ServantAllocatorPrivate {
  rpc RegisterServant (RegisterServantRequest) returns (RegisterServantResponse);
  rpc ServantStatus (ServantStatusRequest) returns (ServantStatusResponse);
}

//
// Administration/Configuration API
//
// Auth requirements: IAM admin user
//
//service ServantAllocatorAdmin {
//  rpc ListAllocatedServants (filter) returns (list-of-servants);
//  ...
//}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

message AllocateServantRequest {
  string userId = 1;
  string workflowName = 2;
  string executionId = 3;
  Provisioning provisioning = 4;

  // throws `RESOURCE_EXHAUSTED` on timeout
  // `0` - no time limit
  int32 timeoutSec = 5;
}

message AllocateServantResponse {
  // unique servant id
  string servantId = 1;

  // servant API address in `host:port` format
  string servantAddress = 2;

  // servant FS API (Slot API) address in `host:port` format
  string servantFsAddress = 3;

  // some key-value metadata
  // as-is from `RegisterServant` call
  // servant may fill this meta with any servant-specific data
  map<string, string> meta = 4;
}

message RegisterServantRequest {
  // servantId, taken from bootstrap request
  string servantId = 1;

  // servant API address in `host:port` format
  string servantAddress = 2;

  // servant FS API (Slot API) address in `host:port` format
  string servantFsAddress = 3;

  // some key-value metadata
  // servant may fill this meta with any servant-specific data
  map<string, string> meta = 4;
}

message ServantAuth {
  // all requests from a servant must be signed with this token
  string iamToken = 1;
}

message RegisterServantResponse {
  ServantAuth auth = 1;
}

message ServantStatus {
  // servant pod was successfully started
  message Started {
  }

  // start new task configuration and execution
  message StartTask {
    string taskId = 1;
  }

  // servant runs task
  message ExecuteTask {
    string taskId = 1;
  }

  // task execution was completed
  message FinishTask {
    string taskId = 1;
  }

  // just a hearth-bit when the servant is idle
  message Idle {
    // list of not flushed output slots
    repeated Slot dirtySlots = 1;
  }

  // servant terminated
  message Finished {
  }

  oneof status {
    Started servantStarted = 1;
    StartTask startTask = 2;
    ExecuteTask executeTask = 3;
    FinishTask finishTask = 4;
    Idle idle = 5;
    Finished finished = 6;
  }
}

message ServantStatusRequest {
  string servantId = 1;
  ServantStatus status = 2;
}

message ServantStatusResponse {
  // auth update
  /* optional */ ServantAuth auth = 1;
}
